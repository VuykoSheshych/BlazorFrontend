@page "/game/active/{gameId}"

@attribute [Authorize]
@inject GameHubClient GameHubClient
@inject NavigationManager NavigationManager
@inject IDialogService DialogService
@inject ChessBoardService ChessBoardService

<h3>[DEBUG] Game: @gameId</h3>

@if (gameSession is not null)
{
	<MudText Typo="Typo.body1">[DEBUG] Current FEN: @gameSession.CurrentFen</MudText>

	<MudText Typo="Typo.h4">PlayerBlack: @gameSession.PlayerBlack</MudText>

	@if (chessBoard != null)
	{
		<MudGrid Spacing="0">
			@for (int row = 0; row <= 7; row++)
			{
				var r = row;

				<MudItem xs="12">
					<MudGrid Spacing="0">
						@for (int col = 0; col <= 7; col++)
						{
							var c = col;
							var squareColor = (r + c) % 2 == 0 ? Colors.Yellow.Accent1 : Colors.Gray.Darken1;

							<MudPaper Style="@($"background:{squareColor};")">
								<MudButton Style="height:60px; width:60px;" Class="align-center justify-center mud-width-full py-8"
									Variant="Variant.Filled" OnClick="() => OnSquareClick(r, c)">
									<MudText Typo="Typo.h3">@GetPieceSymbol(r, c)</MudText>
								</MudButton>
							</MudPaper>
						}
					</MudGrid>
				</MudItem>
			}
		</MudGrid>
	}

	<MudText Typo="Typo.h4">PlayerWhite: @gameSession.PlayerWhite</MudText>

	<MudText Typo="Typo.h4">Result: @gameSession.Result</MudText>

	@foreach (var r in results)
	{
		<MudButton Variant="Variant.Outlined" @onclick="() => FinishGame(r)">@($"{r}")</MudButton>
	}
}
else
{
	<p>Loading game...</p>
}

@code {
	[Parameter] public string? gameId { get; set; }
	private GameSession? gameSession;
	private char[,]? chessBoard;
	protected override async Task OnInitializedAsync()
	{
		if (gameId is not null)
		{
			await GameHubClient.Connect();

			GameHubClient.OnGameStateReceived += OnGameStateReceived;
			GameHubClient.OnMoveReceived += OnMoveReceived;
			GameHubClient.OnGameFinished += OnGameFinished;
		}
	}
	private void OnSquareClick(int row, int col)
	{
		Console.WriteLine($"Square clicked: {row},{col}");
	}

	private char GetPieceSymbol(int row, int col)
	{
		if (row < 0 || row >= 8 || col < 0 || col >= 8 || chessBoard == null)
		{
			return ' ';
		}

		var piece = chessBoard[row, col];

		return piece switch
		{
			'r' => '♜',
			'n' => '♞',
			'b' => '♝',
			'q' => '♛',
			'k' => '♚',
			'p' => '♟',
			'R' => '♖',
			'N' => '♘',
			'B' => '♗',
			'Q' => '♕',
			'K' => '♔',
			'P' => '♙',
			_ => ' ',
		};
	}
	private void OnGameStateReceived(GameSession state)
	{
		gameSession = state;

		if (gameSession?.CurrentFen != null)
		{
			chessBoard = ChessBoardService.ConvertFenToMatrix(gameSession.CurrentFen);
		}

		StateHasChanged();
	}
	private void OnMoveReceived(MoveDto move)
	{
		StateHasChanged();
	}
	private Task OnGameFinished(string result)
	{
		var options = new DialogOptions
		{
			CloseOnEscapeKey = false,
			BackdropClick = false,
			Position = DialogPosition.TopCenter
		};
		var parameters = new DialogParameters { ["Result"] = result };

		return DialogService.ShowAsync<FinishGameDialog>("Гра завершена", parameters, options);
	}
	private List<string> results = new()
{
"1 0",
"0 1",
"0.5 0.5"
};

	private async Task MakeMove(string from, string to)
	{
		if (gameId is not null)
		{
			var move = new MoveDto { From = from, To = to };
			await GameHubClient.MakeMove(gameId, move);
		}
	}
	private async Task FinishGame(string result)
	{
		if (gameSession != null)
		{
			gameSession.Result = result;

			await GameHubClient.FinishGame(gameSession.Id, result);
		}
	}
	public void Dispose()
	{
		GameHubClient.OnGameStateReceived -= OnGameStateReceived;
		GameHubClient.OnMoveReceived -= OnMoveReceived;
		GameHubClient.OnGameFinished -= OnGameFinished;
	}
}