@page "/game/active/{gameId}"

@attribute [Authorize]
@inject GameHubClient GameHubClient
@inject NavigationManager NavigationManager
@inject IDialogService DialogService

@if (gameSession is not null)
{
	@if(moveResult.Contains("[ERROR]"))
	{
		<MudAlert Severity="Severity.Error" Variant="Variant.Outlined">@moveResult.Replace("[ERROR] ", "")</MudAlert>
	}

	<MudText Typo="Typo.h4">Opponent: @(currentUser == gameSession.PlayerBlack ? gameSession.PlayerWhite : gameSession.PlayerBlack)</MudText>

	<MudGrid Spacing="6">
		<MudItem xs="12" sm="12" md="6" lg="6" xl="6" class="d-flex align-center justify-center">
			<ChessBoard Board="chessBoard" OnSquareClicked="OnSquareClick" IsBlack="@(currentUser == gameSession.PlayerBlack)" SelectedSquare="@selectedSquare"/>
		</MudItem>

		<MudItem xs="12" sm="12" md="4" lg="4" xl="4">
			<MudGrid Spacing="5" Justify="Justify.Center">
				<MudItem xs="12" class="d-flex align-center">
					<GameNotation Moves="gameSession.Moves"></GameNotation>
				</MudItem>

				<MudItem xs="12" class="d-flex align-center">
					<MudButton Variant="Variant.Outlined" Color="Color.Warning" @onclick="() => FinishGame(currentUser!)">
						<MudText Typo="Typo.body1">Concede</MudText>
					</MudButton>
				</MudItem>

				<MudItem xs="12" class="d-flex align-center border-double">
					<div style="height: 200px; overflow-y: auto;">
						CHAT
						<!-- Вміст чату тут -->
					</div>
				</MudItem>
			</MudGrid>
		</MudItem>
	</MudGrid>

	<MudText Typo="Typo.h4">You: @currentUser</MudText>
}
else
{
	<MudProgressCircular Indeterminate Color="Color.Primary" />
}

@code {
	[Parameter] public string? gameId { get; set; }
	private GameSession? gameSession;
	private string? currentUser;
	private char[,]? chessBoard;
	private (int row, int col)? selectedSquare;
	private string moveResult = "[SUCСESS]";
	protected override async Task OnInitializedAsync()
	{
		if (gameId is not null)
		{
			await GameHubClient.Connect();
			currentUser = await GameHubClient.GetCurrentUserAsync();

			GameHubClient.OnGameStateReceived += OnGameStateReceived;
			GameHubClient.OnMoveRecieved += OnMoveRecieved;
			GameHubClient.OnGameFinished += OnGameFinished;
		}
	}
	private async Task OnSquareClick((int row, int col) position)
	{
		if (chessBoard == null || gameSession == null) return;

		char piece = chessBoard[position.row, position.col];

		bool isCurrentUserWhite = currentUser == gameSession.PlayerWhite;

		if (selectedSquare == null) 
		{
			// Якщо це вибрана фігура належить противнику – не даємо її обрати
			if ((isCurrentUserWhite && char.IsLower(piece)) || (!isCurrentUserWhite && char.IsUpper(piece))) return;

			else selectedSquare = position;
		}
		else
		{
			// Якщо гравець повторно натискає на обрану фігуру
			if(selectedSquare == position) 
			{
				selectedSquare = null;
				return;
			}

			// Якщо гравець робить хід не під час своєї черги – повідомляемо про неможливість подібного
			else if((IsWhiteTurn() && !isCurrentUserWhite) || (!IsWhiteTurn() && isCurrentUserWhite))
			{
				OnMoveRecieved("[ERROR] It's not your turn to move!");
				return;
			}

			var from = selectedSquare.Value;
			var to = position;

			await MakeMove(from, to);

			selectedSquare = null;
		}
		
		StateHasChanged();
	}
	private void OnGameStateReceived(GameSession state)
	{
		gameSession = state;

		if (gameSession?.CurrentFen != null)
		{
			chessBoard = ChessBoardService.ConvertFenToMatrix(gameSession.CurrentFen);
		}

		StateHasChanged();
	}
	private void OnMoveRecieved(string moveResult)
    {
        this.moveResult = moveResult;
        
        if (moveResult.Contains("[ERROR]")) HideMoveAlertAfterDelay();

        StateHasChanged();
    }
    private async void HideMoveAlertAfterDelay()
    {
        await Task.Delay(1000);
        moveResult = "[SUCCESS]";
        StateHasChanged();
    }
	private Task OnGameFinished(string looser)
	{
		var options = new DialogOptions
		{
			CloseOnEscapeKey = false,
			BackdropClick = false,
			Position = DialogPosition.TopCenter
		};
		var parameters = new DialogParameters { ["Looser"] = looser, ["CurrentUser"] = currentUser };

		return DialogService.ShowAsync<FinishGameDialog>("The game ended", parameters, options);
	}
	private bool IsWhiteTurn()
	{
		// Якщо ігрова сесія не існує, то за замовчуванням хід білих
		if(gameSession == null) return true;
		
		// Якщо ігрова сесія не має ходів, то за замовчуванням хід білих
		if(!gameSession.Moves.Any()) return true;

		// Якщо останній хід в грі був за чорними, то за хід білих
		if(gameSession.Moves.Last().PlayerColor == "b") return true;
		
		return false; // В усіх інших випадках хід чорних
	}
	private async Task MakeMove((int row, int col) from, (int row, int col) to)
    {
		if (gameSession == null || gameId == null) return;

		bool isCurrentUserWhite = currentUser == gameSession.PlayerWhite; // Чи білий цей гравець

		var move = new MoveDto
		{
			From = $"{(char)('a' + from.col)}{8 - from.row}",
			To = $"{(char)('a' + to.col)}{8 - to.row}"
		};

		await GameHubClient.MakeMove(gameId, move);
		selectedSquare = null;
		StateHasChanged();
    }
	private async Task FinishGame(string looser)
	{
		if (gameSession != null)
		{
			gameSession.Result = looser;

			await GameHubClient.FinishGame(gameSession.Id, looser);
		}
	}
	public void Dispose()
	{
		GameHubClient.OnGameStateReceived -= OnGameStateReceived;
		GameHubClient.OnMoveRecieved -= OnMoveRecieved;
		GameHubClient.OnGameFinished -= OnGameFinished;
	}
}