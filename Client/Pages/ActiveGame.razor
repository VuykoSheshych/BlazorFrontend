@page "/game/active/{gameId}"

@attribute [Authorize]
@inject GameHubClient GameHubClient
@inject NavigationManager NavigationManager
@inject IDialogService DialogService
@inject ChessBoardService ChessBoardService

<h3>[DEBUG] Game: @gameId</h3>

@if (gameSession is not null)
{
	@if(moveResult == "You cannot make moves with your opponent's pieces!" ||
		moveResult == "Invalid move for this type of piece!" ||
		moveResult == "The final square is already occupied by an allied piece!")
	{
	<MudAlert Severity="Severity.Error" Variant="Variant.Outlined">@moveResult</MudAlert>
	}

	<MudText Typo="Typo.body1">[DEBUG] Current FEN: @gameSession.CurrentFen</MudText>

	<MudText Typo="Typo.h4">Opponent: @(currentUser == gameSession.PlayerBlack ? gameSession.PlayerWhite : gameSession.PlayerBlack)</MudText>

	@if (chessBoard != null)
	{
		<ChessBoard Board="chessBoard" OnSquareClicked="OnSquareClick" IsBlack="@(currentUser == gameSession.PlayerBlack)" />
	}

	<MudText Typo="Typo.h4">You: @currentUser</MudText>

	<MudText Typo="Typo.h4">Result: @gameSession.Result</MudText>

	@foreach (var r in results)
	{
		<MudButton Variant="Variant.Outlined" @onclick="() => FinishGame(r)">@($"{r}")</MudButton>
	}
}
else
{
	<p>Loading game...</p>
}

@code {
	[Parameter] public string? gameId { get; set; }
	private GameSession? gameSession;
	private string? currentUser;
	private char[,]? chessBoard;
	private (int row, int col)? selectedSquare;
	private string moveResult = "Move is correct.";
	private List<string> results = new()
	{
		"White",
		"Black",
		"Draw"
	};
	protected override async Task OnInitializedAsync()
	{
		if (gameId is not null)
		{
			await GameHubClient.Connect();
			currentUser = await GameHubClient.GetCurrentUserAsync();

			GameHubClient.OnGameStateReceived += OnGameStateReceived;
			GameHubClient.OnMoveRecieved += OnMoveRecieved;
			GameHubClient.OnGameFinished += OnGameFinished;
		}
	}
	private async Task OnSquareClick((int row, int col) position)
	{
		if (selectedSquare.HasValue)
        {
            var from = selectedSquare.Value;
            var to = position;

            await MakeMove(from, to);
            selectedSquare = null;
		}
		else
        {
            selectedSquare = position;
        }
	}
	private void OnGameStateReceived(GameSession state)
	{
		gameSession = state;

		if (gameSession?.CurrentFen != null)
		{
			chessBoard = ChessBoardService.ConvertFenToMatrix(gameSession.CurrentFen);
		}

		StateHasChanged();
	}
	private void OnMoveRecieved(string moveResult)
    {
        this.moveResult = moveResult;
        
        if (moveResult == "You cannot make moves with your opponent's pieces!" ||
			moveResult == "Invalid move for this type of piece!" ||
			moveResult == "The final square is already occupied by an allied piece!") HideMoveAlertAfterDelay();

        StateHasChanged();
    }
    private async void HideMoveAlertAfterDelay()
    {
        await Task.Delay(1000);
        moveResult = "Move is correct.";
        StateHasChanged();
    }
	private Task OnGameFinished(string winner)
	{
		var options = new DialogOptions
		{
			CloseOnEscapeKey = false,
			BackdropClick = false,
			Position = DialogPosition.TopCenter
		};
		var parameters = new DialogParameters { ["Winner"] = winner, ["CurrentUser"] = currentUser };

		return DialogService.ShowAsync<FinishGameDialog>("The game ended", parameters, options);
	}
	private async Task MakeMove((int row, int col) from, (int row, int col) to)
    {
        if (gameId is not null)
        {
            var move = new MoveDto
            {
                From = $"{(char)('a' + from.col)}{8 - from.row}",
                To = $"{(char)('a' + to.col)}{8 - to.row}"
            };

            await GameHubClient.MakeMove(gameId, move);
        }
    }
	private async Task FinishGame(string result)
	{
		if (gameSession != null)
		{
			gameSession.Result = result;

			await GameHubClient.FinishGame(gameSession.Id, result);
		}
	}
	public void Dispose()
	{
		GameHubClient.OnGameStateReceived -= OnGameStateReceived;
		GameHubClient.OnMoveRecieved -= OnMoveRecieved;
		GameHubClient.OnGameFinished -= OnGameFinished;
	}
}